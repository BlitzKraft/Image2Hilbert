<html>
<head>
</head>
<script>

//http://www.icodeguru.com/Embedded/Hacker's-Delight/095.htm

var ctx = null
var x = 10, y = 10
var imgctx = null

function start()
{
    imgctx = imgCanvas.getContext('2d')
    imgctx.drawImage(fromImg, 0, 0, 256, 256)

    var path = hilbertCurve()

    console.log("BEFORE="+path.length)
    path = dedup(path);
    console.log("AFTER="+path.length)
    
    var text = outToSvg(path)
    showSvg.innerHTML = text
    
   // outToCanvas(path)


}


function outToSvg(path) 
{
    var sz = 256*3
    var text = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + sz +'" height="'+ sz +'">'
    text += '<g><polyline style="fill:none;stroke:#000000;" points="'
    
       //d="m 502.85714,262.3622 -180,92.85715 164.28572,134.28571 157.14285,-44.28571 28.57143,-185.71429 -17.14285,-102.85714"

    for(i = 0; i < path.length; ++i) {
        text += path[i][0] + "," + path[i][1] + " "
        
    }
    text += '"/></g></svg>'
    return text
}

function outToCanvas(path)
{
    ctx = theCanvas.getContext('2d')
    ctx.beginPath();
    ctx.moveTo(path[0][0], path[0][1]);
    
    //for(i in path) {
    for(i = 0; i < path.length; ++i) {
        ctx.lineTo(path[i][0], path[i][1])
    }
    
    ctx.stroke()
}


function dedup(path)
{
    var sz = path.length
    var cp = []
    for(var i = 1; i < sz-1; ++i)
    {
        if ((path[i-1][0] == path[i][0] && path[i][0] == path[i+1][0]) || 
            (path[i-1][1] == path[i][1] && path[i][1] == path[i+1][1])) {
            continue
        }
        cp.push(path[i])
    }
    return cp
}


var hilbert = (function() {

  var pairs = [
    [[0, 3], [1, 0], [3, 1], [2, 0]],
    [[2, 1], [1, 1], [3, 0], [0, 2]],
    [[2, 2], [3, 3], [1, 2], [0, 1]],
    [[0, 0], [3, 2], [1, 3], [2, 3]]
  ];
  // d2xy and rot are from:
  // http://en.wikipedia.org/wiki/Hilbert_curve#Applications_and_mapping_algorithms
  function rot(n, x, y, rx, ry) {
    if (ry === 0) {
      if (rx === 1) {
        x = n - 1 - x;
        y = n - 1 - y;
      }
      return [y, x];
    }
    return [x, y];
  }
  return {
    xy2d: function(x, y, z) {
      var quad = 0,
          pair,
          i = 0;
      while (--z >= 0) {
        pair = pairs[quad][(x & (1 << z) ? 2 : 0) | (y & (1 << z) ? 1 : 0)];
        i = (i << 2) | pair[0];
        quad = pair[1];
      }
      return i;
    },
    d2xy: function(z, t) {
      var n = 1 << z,
          x = 0,
          y = 0;
      for (var s = 1; s < n; s *= 2) {
        var rx = 1 & (t / 2),
            ry = 1 & (t ^ rx);
        var xy = rot(s, x, y, rx, ry);
        x = xy[0] + s * rx;
        y = xy[1] + s * ry;
        t /= 4;
      }
      return [x, y];
    }
  };
})();

function check(crd, cf) {
    var x = crd[0]*cf, y = crd[1]*cf
    //return x + y < 256
    // this is slow
    var imgData = imgctx.getImageData(x, y, 1, 1);
    return imgData.data[0] < 50
}

function hilbertCurve() {

    //var mx = 1 << (level * 2)
    var coord =[0,0]
    var lvl = 5
    var seg = 10
    var count = 0
    var lastCheck = false
    var i = 0
    var cf = 1
    var first = true
    var avoided = 0
    
    var path = [coord]
    
    while(count < 540000)
    {
        var curCheck = check(coord, cf)
        if (curCheck != lastCheck || first) {
            first = false
            if (curCheck) {
                lvl = 7
                seg = 6
                cf = 2 
                i = hilbert.xy2d(coord[0]/2, coord[1]/2, lvl)
            }
            else {
                lvl = 8
                seg = 3
                cf = 1
                i = hilbert.xy2d(coord[0]*2, coord[1]*2, lvl)
            }
            ++i // skip it to avoid a loop
        }
        else {
            ++i;
        }
        
        lastCoord = coord
        lastCheck = curCheck
        coord = hilbert.d2xy(lvl, i)
        var rx = coord[0]*seg
        var ry = coord[1]*seg
        path.push([rx,ry])
    //    ctx.lineTo(rx + 10, ry + 10)
        ++count;
        if (rx > 253*3 && ry == 0)
            break;
        //console.log(" " + coord[0] + " " + coord[1]) 
        //console.log(" " + coord[0] + " " + coord[1]) 
    }
    return path
  
}

function hilbert(dir, rot, order) {
    if (x > 100) {
        dest = 0
        sz = 5
    }
    else {
        dest = 1
        sz = 10
    }
    
    if (order < dest) 
        return; 
    
    dir = dir + rot; 
    hilbert(dir, -rot, order - 1); 
    step(dir, sz); 
    dir = dir - rot; 
    hilbert(dir, rot, order - 1); 
    step(dir, sz); 
    hilbert(dir, rot, order - 1); 
    dir = dir - rot; 
    step(dir, sz); 
    hilbert(dir, -rot, order - 1); 
} 

function step(dir, sz) {
    //var sz = 5 //10
    switch(dir & 3) {
    case 0: x = x + sz; break; 
    case 1: y = y + sz; break; 
    case 2: x = x - sz; break; 
    case 3: y = y - sz; break; 
    }
    ctx.lineTo(x, y);
    //ctx.stroke()
}


</script>
<style>
#theCanvas {
    display:none
}
#imgCanvas {
    border: 1px black solid;
}
</style>
<body onload="start()">

<div id="showSvg"></div>
<canvas id="theCanvas" width="800" height="800"></canvas><br>
<canvas id="imgCanvas" width="256" height="256"></canvas><br>

<img id="fromImg" src="test.png">
</body>

</html>