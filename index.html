<html>
<head>
<title>Image To Hilbert curve</title>
</head>
<script>

//http://www.icodeguru.com/Embedded/Hacker's-Delight/095.htm

var ctx = null
var x = 10, y = 10
var imgctx = null

var SZ = 256
var WIDTH = 2*SZ
var HEIGHT = SZ

function start()
{
    imgctx = imgCanvas.getContext('2d')
    //imgctx.drawImage(fromImg, 0, 0, 256, 256)
    imgctx.fillStyle = 'white'
    imgctx.fillRect(0, 0, WIDTH, HEIGHT)

    makeCurve()
    
   // outToCanvas(path)

    imgCanvas.onmousedown = handleMouseDown
    document.onmouseup = handleMouseUp
    document.onmousemove = handleMouseMove
}


var pressedInCanvas = false
function handleMouseDown(event) {
    pressedInCanvas = true
    addCircle(event.clientX, event.clientY)
}
function handleMouseMove(event) {
    if (pressedInCanvas) {
        addCircle(event.clientX, event.clientY)
        makeCurve()
    }
}
function handleMouseUp(event) {
    pressedInCanvas = false
    makeCurve()
}

function addCircle(cx, cy) {
    var rect = imgCanvas.getBoundingClientRect()
    var x = cx - rect.left, y = cy - rect.top

    if (brBl.checked)
        imgctx.fillStyle = 'black'
    else if (brGr.checked)
        imgctx.fillStyle = 'gray'
    else if (brWh.checked)
        imgctx.fillStyle = 'white'
    
    imgctx.fillRect(x, y, 10, 10) // brush size
}

function triggerFileChanged() 
{
    if (editFileInput.files.length == 0)
        return
    var file = editFileInput.files[0]
    
    fromImg.onload = function() {
        imgctx.fillRect(0, 0, WIDTH, HEIGHT)
        imgctx.drawImage(fromImg, 0, 0, WIDTH, HEIGHT)
        makeCurve()
    }
    var reader = new FileReader();
    reader.onload = function(e) { 
        fromImg.src = e.target.result //, blob.type
    }
    reader.onerror = function(e) {
        console.log(e)
    }
    reader.readAsDataURL(file); // read as data URL since we want to put it in an img src

}


function makeCurve()
{
    var path = hilbertCurve(0)
    path = dedup(path);

    var path2 = hilbertCurve(256)
    path2 = dedup(path2);

    var text = outToSvg(path, path2)
    showSvg.innerHTML = text

}

function outToSvg(path, path2) 
{
    var sz = SZ*3
    var text = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + (2*sz) +'" height="'+ sz +'">'
    text += '<g><polyline id="pl1" style="fill:none;stroke:#000000;" points="'
    
    for(i = 0; i < path.length; ++i) {
        text += path[i][0] + "," + path[i][1] + " "
    }
  //  text += '"/><polyline id="pl2" style="fill:none;stroke:#000000;" points="'

    for(i = 0; i < path2.length; ++i) {
        text += (path2[i][0] + 768) + "," + path2[i][1] + " "
    }
    
    text += '"/></g></svg>'
    return text
}

function outToCanvas(path)
{
    ctx = theCanvas.getContext('2d')
    ctx.beginPath();
    ctx.moveTo(path[0][0], path[0][1]);
    
    //for(i in path) {
    for(i = 0; i < path.length; ++i) {
        ctx.lineTo(path[i][0], path[i][1])
    }
    
    ctx.stroke()
}


function dedup(path)
{
    var sz = path.length
    var cp = []
    for(var i = 1; i < sz-1; ++i)
    {
        if ((path[i-1][0] == path[i][0] && path[i][0] == path[i+1][0]) || 
            (path[i-1][1] == path[i][1] && path[i][1] == path[i+1][1])) {
            continue
        }
        cp.push(path[i])
    }
    return cp
}


var hilbert = (function() {

  var pairs = [
    [[0, 3], [1, 0], [3, 1], [2, 0]],
    [[2, 1], [1, 1], [3, 0], [0, 2]],
    [[2, 2], [3, 3], [1, 2], [0, 1]],
    [[0, 0], [3, 2], [1, 3], [2, 3]]
  ];
  // d2xy and rot are from:
  // http://en.wikipedia.org/wiki/Hilbert_curve#Applications_and_mapping_algorithms
  function rot(n, x, y, rx, ry) {
    if (ry === 0) {
      if (rx === 1) {
        x = n - 1 - x;
        y = n - 1 - y;
      }
      return [y, x];
    }
    return [x, y];
  }
  return {
    xy2d: function(x, y, z) {
      var quad = 0,
          pair,
          i = 0;
      while (--z >= 0) {
        pair = pairs[quad][(x & (1 << z) ? 2 : 0) | (y & (1 << z) ? 1 : 0)];
        i = (i << 2) | pair[0];
        quad = pair[1];
      }
      return i;
    },
    d2xy: function(z, t) {
      var n = 1 << z,
          x = 0,
          y = 0;
      for (var s = 1; s < n; s *= 2) {
        var rx = 1 & (t / 2),
            ry = 1 & (t ^ rx);
        var xy = rot(s, x, y, rx, ry);
        x = xy[0] + s * rx;
        y = xy[1] + s * ry;
        t /= 4;
      }
      return [x, y];
    }
  };
})();

var imgData = null
function preCheck() {
    imgData = imgctx.getImageData(0, 0, 2*SZ, SZ);
    
}

function check(crd, cf, xSampleOffset) 
{
    var x = crd[0]*cf + xSampleOffset, y = crd[1]*cf
    //return x + y < 256
    // this is slow
    //var imgData = imgctx.getImageData(x, y, 1, 1);
    var r = imgData.data[4*(y*WIDTH + x )]
    if (r < 50)
        return 2
    else if (r > 50 && r < 150)
        return 1
    return 0
}

function hilbertCurve(xSampleOffset) 
{
    preCheck()
    //var mx = 1 << (level * 2)
    var coord =[0,0]
    var lvl = 5
    var seg = 10
    var count = 0
    var lastCheck = -1
    var i = 0
    var cf = 1 // check factor
    var first = true
    var avoided = 0
    var maxi = 0
    var path = [coord]
    
    while(count < 540000)
    {
        var curCheck = check(coord, cf, xSampleOffset)
        if (curCheck != lastCheck || first) 
        {
            first = false
            var prevCf = cf
            if (curCheck == 0) {
                lvl = 6
                seg = 12
                cf = 4 
                maxi = 64*64
            }
            else if (curCheck == 1) {
                lvl = 7
                seg = 6
                cf = 2 
                maxi = 128*128
            }
            else {
                lvl = 8
                seg = 3
                cf = 1
                maxi = 256*256
            }

            var relFactor = prevCf / cf 
            i = hilbert.xy2d(coord[0]*relFactor, coord[1]*relFactor, lvl)

            ++i // skip it to avoid a loop
        }
        else {
            ++i;
        }
        
        lastCoord = coord
        lastCheck = curCheck
        coord = hilbert.d2xy(lvl, i)
        var rx = coord[0]*seg
        var ry = coord[1]*seg
        path.push([rx,ry])
    //    ctx.lineTo(rx + 10, ry + 10)
        ++count;
        if (i > maxi-1)
            break;
       // if (rx > 253*3 && ry == 0)
       //     break;
        //console.log(" " + coord[0] + " " + coord[1]) 
        //console.log(" " + coord[0] + " " + coord[1]) 
    }

    return path
  
}



</script>
<style>
#theCanvas {
    display:none
}
#imgCanvas {
    border: 1px black solid;
}
#fromImg {
    display:none
}
#ctrl {

}
#editFileInput {
    position: absolute;
    top: 10px;
    left: 100px;
}
#showSvg {
    position: absolute;
    top: 350;
    margin:5px 0 5px 5px;
}

</style>
<body onload="start()">
<div id="ctrl">
  <input id="brWh" type="radio" name="brush" value="white">White<br>
  <input id="brGr" type="radio" name="brush" value="gray">Gray<br>
  <input id="brBl" type="radio" name="brush" value="black" checked>Black<br>
   <input id="editFileInput" type="file" class="hidden" onchange="return triggerFileChanged()">
</div>
<canvas id="imgCanvas" width="512" height="256"></canvas><br>
<div id="showSvg"></div>


<img id="fromImg" src="test.png">
</body>

</html>